/*
 * This file is auto-generated! Do not modify it directly.
 * To re-generate run 'make build'
 */
import shallowEqual from "../../utils/shallowEqual";

export function isArrayExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ArrayExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isAssignmentExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "AssignmentExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isBinaryExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "BinaryExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isInterpreterDirective(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "InterpreterDirective") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDirective(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "Directive") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDirectiveLiteral(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "DirectiveLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isBlockStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "BlockStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isBreakStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "BreakStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isCallExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "CallExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isCatchClause(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "CatchClause") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isConditionalExpression(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ConditionalExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isContinueStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ContinueStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDebuggerStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "DebuggerStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDoWhileStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "DoWhileStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isEmptyStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "EmptyStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isExpressionStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ExpressionStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isFile(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "File") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isForInStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ForInStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isForStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ForStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isFunctionDeclaration(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "FunctionDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isFunctionExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "FunctionExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isIdentifier(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "Identifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isIfStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "IfStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isLabeledStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "LabeledStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isStringLiteral(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "StringLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isNumericLiteral(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "NumericLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isNullLiteral(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "NullLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isBooleanLiteral(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "BooleanLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isRegExpLiteral(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "RegExpLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isLogicalExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "LogicalExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isMemberExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "MemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isNewExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "NewExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isProgram(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "Program") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isObjectExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ObjectExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isObjectMethod(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ObjectMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isObjectProperty(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ObjectProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isRestElement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "RestElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isReturnStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ReturnStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isSequenceExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "SequenceExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isParenthesizedExpression(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ParenthesizedExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isSwitchCase(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "SwitchCase") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isSwitchStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "SwitchStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isThisExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ThisExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isThrowStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ThrowStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTryStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TryStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isUnaryExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "UnaryExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isUpdateExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "UpdateExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isVariableDeclaration(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "VariableDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isVariableDeclarator(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "VariableDeclarator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isWhileStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "WhileStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isWithStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "WithStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isAssignmentPattern(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "AssignmentPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isArrayPattern(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ArrayPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isArrowFunctionExpression(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ArrowFunctionExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isClassBody(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ClassBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isClassExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ClassExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isClassDeclaration(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ClassDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isExportAllDeclaration(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ExportAllDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isExportDefaultDeclaration(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ExportDefaultDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isExportNamedDeclaration(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ExportNamedDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isExportSpecifier(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ExportSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isForOfStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ForOfStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isImportDeclaration(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ImportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isImportDefaultSpecifier(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ImportDefaultSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isImportNamespaceSpecifier(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ImportNamespaceSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isImportSpecifier(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ImportSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isMetaProperty(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "MetaProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isClassMethod(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ClassMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isObjectPattern(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ObjectPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isSpreadElement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "SpreadElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isSuper(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "Super") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTaggedTemplateExpression(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TaggedTemplateExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTemplateElement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TemplateElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTemplateLiteral(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TemplateLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isYieldExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "YieldExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isAwaitExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "AwaitExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isImport(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "Import") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isBigIntLiteral(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "BigIntLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isExportNamespaceSpecifier(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ExportNamespaceSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isOptionalMemberExpression(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "OptionalMemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isOptionalCallExpression(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "OptionalCallExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isAnyTypeAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "AnyTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isArrayTypeAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ArrayTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isBooleanTypeAnnotation(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "BooleanTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isBooleanLiteralTypeAnnotation(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "BooleanLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isNullLiteralTypeAnnotation(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "NullLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isClassImplements(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ClassImplements") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDeclareClass(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "DeclareClass") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDeclareFunction(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "DeclareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDeclareInterface(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "DeclareInterface") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDeclareModule(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "DeclareModule") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDeclareModuleExports(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "DeclareModuleExports") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDeclareTypeAlias(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "DeclareTypeAlias") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDeclareOpaqueType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "DeclareOpaqueType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDeclareVariable(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "DeclareVariable") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDeclareExportDeclaration(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "DeclareExportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDeclareExportAllDeclaration(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "DeclareExportAllDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDeclaredPredicate(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "DeclaredPredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isExistsTypeAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ExistsTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isFunctionTypeAnnotation(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "FunctionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isFunctionTypeParam(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "FunctionTypeParam") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isGenericTypeAnnotation(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "GenericTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isInferredPredicate(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "InferredPredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isInterfaceExtends(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "InterfaceExtends") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isInterfaceDeclaration(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "InterfaceDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isInterfaceTypeAnnotation(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "InterfaceTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isIntersectionTypeAnnotation(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "IntersectionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isMixedTypeAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "MixedTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isEmptyTypeAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "EmptyTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isNullableTypeAnnotation(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "NullableTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isNumberLiteralTypeAnnotation(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "NumberLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isNumberTypeAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "NumberTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isObjectTypeAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ObjectTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isObjectTypeInternalSlot(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ObjectTypeInternalSlot") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isObjectTypeCallProperty(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ObjectTypeCallProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isObjectTypeIndexer(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ObjectTypeIndexer") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isObjectTypeProperty(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ObjectTypeProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isObjectTypeSpreadProperty(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ObjectTypeSpreadProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isOpaqueType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "OpaqueType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isQualifiedTypeIdentifier(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "QualifiedTypeIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isStringLiteralTypeAnnotation(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "StringLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isStringTypeAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "StringTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isSymbolTypeAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "SymbolTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isThisTypeAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ThisTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTupleTypeAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TupleTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTypeofTypeAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TypeofTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTypeAlias(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TypeAlias") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTypeAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTypeCastExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TypeCastExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTypeParameter(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TypeParameter") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTypeParameterDeclaration(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TypeParameterDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTypeParameterInstantiation(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TypeParameterInstantiation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isUnionTypeAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "UnionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isVariance(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "Variance") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isVoidTypeAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "VoidTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isEnumDeclaration(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "EnumDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isEnumBooleanBody(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "EnumBooleanBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isEnumNumberBody(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "EnumNumberBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isEnumStringBody(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "EnumStringBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isEnumSymbolBody(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "EnumSymbolBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isEnumBooleanMember(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "EnumBooleanMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isEnumNumberMember(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "EnumNumberMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isEnumStringMember(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "EnumStringMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isEnumDefaultedMember(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "EnumDefaultedMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isJSXAttribute(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "JSXAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isJSXClosingElement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "JSXClosingElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isJSXElement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "JSXElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isJSXEmptyExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "JSXEmptyExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isJSXExpressionContainer(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "JSXExpressionContainer") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isJSXSpreadChild(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "JSXSpreadChild") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isJSXIdentifier(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "JSXIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isJSXMemberExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "JSXMemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isJSXNamespacedName(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "JSXNamespacedName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isJSXOpeningElement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "JSXOpeningElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isJSXSpreadAttribute(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "JSXSpreadAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isJSXText(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "JSXText") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isJSXFragment(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "JSXFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isJSXOpeningFragment(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "JSXOpeningFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isJSXClosingFragment(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "JSXClosingFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isNoop(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "Noop") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isPlaceholder(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "Placeholder") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isV8IntrinsicIdentifier(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "V8IntrinsicIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isArgumentPlaceholder(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ArgumentPlaceholder") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isBindExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "BindExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isClassProperty(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ClassProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isPipelineTopicExpression(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "PipelineTopicExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isPipelineBareFunction(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "PipelineBareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isPipelinePrimaryTopicReference(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "PipelinePrimaryTopicReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isClassPrivateProperty(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ClassPrivateProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isClassPrivateMethod(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ClassPrivateMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isImportAttribute(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ImportAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDecorator(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "Decorator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDoExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "DoExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isExportDefaultSpecifier(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "ExportDefaultSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isPrivateName(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "PrivateName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isRecordExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "RecordExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTupleExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TupleExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDecimalLiteral(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "DecimalLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isStaticBlock(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "StaticBlock") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSParameterProperty(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSParameterProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSDeclareFunction(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSDeclareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSDeclareMethod(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSDeclareMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSQualifiedName(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSQualifiedName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSCallSignatureDeclaration(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSCallSignatureDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSConstructSignatureDeclaration(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSConstructSignatureDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSPropertySignature(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSPropertySignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSMethodSignature(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSMethodSignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSIndexSignature(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSIndexSignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSAnyKeyword(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSAnyKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSBooleanKeyword(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSBooleanKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSBigIntKeyword(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSBigIntKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSIntrinsicKeyword(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSIntrinsicKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSNeverKeyword(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSNeverKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSNullKeyword(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSNullKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSNumberKeyword(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSNumberKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSObjectKeyword(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSObjectKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSStringKeyword(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSStringKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSSymbolKeyword(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSSymbolKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSUndefinedKeyword(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSUndefinedKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSUnknownKeyword(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSUnknownKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSVoidKeyword(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSVoidKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSThisType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSThisType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSFunctionType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSFunctionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSConstructorType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSConstructorType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSTypeReference(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSTypeReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSTypePredicate(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSTypePredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSTypeQuery(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSTypeQuery") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSTypeLiteral(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSTypeLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSArrayType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSArrayType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSTupleType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSTupleType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSOptionalType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSOptionalType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSRestType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSRestType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSNamedTupleMember(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSNamedTupleMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSUnionType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSUnionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSIntersectionType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSIntersectionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSConditionalType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSConditionalType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSInferType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSInferType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSParenthesizedType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSParenthesizedType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSTypeOperator(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSTypeOperator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSIndexedAccessType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSIndexedAccessType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSMappedType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSMappedType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSLiteralType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSLiteralType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSExpressionWithTypeArguments(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSExpressionWithTypeArguments") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSInterfaceDeclaration(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSInterfaceDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSInterfaceBody(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSInterfaceBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSTypeAliasDeclaration(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSTypeAliasDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSAsExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSAsExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSTypeAssertion(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSTypeAssertion") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSEnumDeclaration(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSEnumDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSEnumMember(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSEnumMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSModuleDeclaration(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSModuleDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSModuleBlock(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSModuleBlock") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSImportType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSImportType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSImportEqualsDeclaration(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSImportEqualsDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSExternalModuleReference(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSExternalModuleReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSNonNullExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSNonNullExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSExportAssignment(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSExportAssignment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSNamespaceExportDeclaration(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSNamespaceExportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSTypeAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSTypeParameterInstantiation(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSTypeParameterInstantiation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSTypeParameterDeclaration(
  node?: any | null,
  opts?: any,
): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSTypeParameterDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSTypeParameter(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "TSTypeParameter") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isExpression(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Expression" ||
    "ArrayExpression" === nodeType ||
    "AssignmentExpression" === nodeType ||
    "BinaryExpression" === nodeType ||
    "CallExpression" === nodeType ||
    "ConditionalExpression" === nodeType ||
    "FunctionExpression" === nodeType ||
    "Identifier" === nodeType ||
    "StringLiteral" === nodeType ||
    "NumericLiteral" === nodeType ||
    "NullLiteral" === nodeType ||
    "BooleanLiteral" === nodeType ||
    "RegExpLiteral" === nodeType ||
    "LogicalExpression" === nodeType ||
    "MemberExpression" === nodeType ||
    "NewExpression" === nodeType ||
    "ObjectExpression" === nodeType ||
    "SequenceExpression" === nodeType ||
    "ParenthesizedExpression" === nodeType ||
    "ThisExpression" === nodeType ||
    "UnaryExpression" === nodeType ||
    "UpdateExpression" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ClassExpression" === nodeType ||
    "MetaProperty" === nodeType ||
    "Super" === nodeType ||
    "TaggedTemplateExpression" === nodeType ||
    "TemplateLiteral" === nodeType ||
    "YieldExpression" === nodeType ||
    "AwaitExpression" === nodeType ||
    "Import" === nodeType ||
    "BigIntLiteral" === nodeType ||
    "OptionalMemberExpression" === nodeType ||
    "OptionalCallExpression" === nodeType ||
    "TypeCastExpression" === nodeType ||
    "JSXElement" === nodeType ||
    "JSXFragment" === nodeType ||
    "BindExpression" === nodeType ||
    "PipelinePrimaryTopicReference" === nodeType ||
    "DoExpression" === nodeType ||
    "RecordExpression" === nodeType ||
    "TupleExpression" === nodeType ||
    "DecimalLiteral" === nodeType ||
    "TSAsExpression" === nodeType ||
    "TSTypeAssertion" === nodeType ||
    "TSNonNullExpression" === nodeType ||
    (nodeType === "Placeholder" &&
      ("Expression" === node.expectedNode ||
        "Identifier" === node.expectedNode ||
        "StringLiteral" === node.expectedNode))
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isBinary(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Binary" ||
    "BinaryExpression" === nodeType ||
    "LogicalExpression" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isScopable(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Scopable" ||
    "BlockStatement" === nodeType ||
    "CatchClause" === nodeType ||
    "DoWhileStatement" === nodeType ||
    "ForInStatement" === nodeType ||
    "ForStatement" === nodeType ||
    "FunctionDeclaration" === nodeType ||
    "FunctionExpression" === nodeType ||
    "Program" === nodeType ||
    "ObjectMethod" === nodeType ||
    "SwitchStatement" === nodeType ||
    "WhileStatement" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ClassExpression" === nodeType ||
    "ClassDeclaration" === nodeType ||
    "ForOfStatement" === nodeType ||
    "ClassMethod" === nodeType ||
    "ClassPrivateMethod" === nodeType ||
    "StaticBlock" === nodeType ||
    "TSModuleBlock" === nodeType ||
    (nodeType === "Placeholder" && "BlockStatement" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isBlockParent(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "BlockParent" ||
    "BlockStatement" === nodeType ||
    "CatchClause" === nodeType ||
    "DoWhileStatement" === nodeType ||
    "ForInStatement" === nodeType ||
    "ForStatement" === nodeType ||
    "FunctionDeclaration" === nodeType ||
    "FunctionExpression" === nodeType ||
    "Program" === nodeType ||
    "ObjectMethod" === nodeType ||
    "SwitchStatement" === nodeType ||
    "WhileStatement" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ForOfStatement" === nodeType ||
    "ClassMethod" === nodeType ||
    "ClassPrivateMethod" === nodeType ||
    "StaticBlock" === nodeType ||
    "TSModuleBlock" === nodeType ||
    (nodeType === "Placeholder" && "BlockStatement" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isBlock(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Block" ||
    "BlockStatement" === nodeType ||
    "Program" === nodeType ||
    "TSModuleBlock" === nodeType ||
    (nodeType === "Placeholder" && "BlockStatement" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Statement" ||
    "BlockStatement" === nodeType ||
    "BreakStatement" === nodeType ||
    "ContinueStatement" === nodeType ||
    "DebuggerStatement" === nodeType ||
    "DoWhileStatement" === nodeType ||
    "EmptyStatement" === nodeType ||
    "ExpressionStatement" === nodeType ||
    "ForInStatement" === nodeType ||
    "ForStatement" === nodeType ||
    "FunctionDeclaration" === nodeType ||
    "IfStatement" === nodeType ||
    "LabeledStatement" === nodeType ||
    "ReturnStatement" === nodeType ||
    "SwitchStatement" === nodeType ||
    "ThrowStatement" === nodeType ||
    "TryStatement" === nodeType ||
    "VariableDeclaration" === nodeType ||
    "WhileStatement" === nodeType ||
    "WithStatement" === nodeType ||
    "ClassDeclaration" === nodeType ||
    "ExportAllDeclaration" === nodeType ||
    "ExportDefaultDeclaration" === nodeType ||
    "ExportNamedDeclaration" === nodeType ||
    "ForOfStatement" === nodeType ||
    "ImportDeclaration" === nodeType ||
    "DeclareClass" === nodeType ||
    "DeclareFunction" === nodeType ||
    "DeclareInterface" === nodeType ||
    "DeclareModule" === nodeType ||
    "DeclareModuleExports" === nodeType ||
    "DeclareTypeAlias" === nodeType ||
    "DeclareOpaqueType" === nodeType ||
    "DeclareVariable" === nodeType ||
    "DeclareExportDeclaration" === nodeType ||
    "DeclareExportAllDeclaration" === nodeType ||
    "InterfaceDeclaration" === nodeType ||
    "OpaqueType" === nodeType ||
    "TypeAlias" === nodeType ||
    "EnumDeclaration" === nodeType ||
    "TSDeclareFunction" === nodeType ||
    "TSInterfaceDeclaration" === nodeType ||
    "TSTypeAliasDeclaration" === nodeType ||
    "TSEnumDeclaration" === nodeType ||
    "TSModuleDeclaration" === nodeType ||
    "TSImportEqualsDeclaration" === nodeType ||
    "TSExportAssignment" === nodeType ||
    "TSNamespaceExportDeclaration" === nodeType ||
    (nodeType === "Placeholder" &&
      ("Statement" === node.expectedNode ||
        "Declaration" === node.expectedNode ||
        "BlockStatement" === node.expectedNode))
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTerminatorless(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Terminatorless" ||
    "BreakStatement" === nodeType ||
    "ContinueStatement" === nodeType ||
    "ReturnStatement" === nodeType ||
    "ThrowStatement" === nodeType ||
    "YieldExpression" === nodeType ||
    "AwaitExpression" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isCompletionStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "CompletionStatement" ||
    "BreakStatement" === nodeType ||
    "ContinueStatement" === nodeType ||
    "ReturnStatement" === nodeType ||
    "ThrowStatement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isConditional(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Conditional" ||
    "ConditionalExpression" === nodeType ||
    "IfStatement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isLoop(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Loop" ||
    "DoWhileStatement" === nodeType ||
    "ForInStatement" === nodeType ||
    "ForStatement" === nodeType ||
    "WhileStatement" === nodeType ||
    "ForOfStatement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isWhile(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "While" ||
    "DoWhileStatement" === nodeType ||
    "WhileStatement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isExpressionWrapper(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "ExpressionWrapper" ||
    "ExpressionStatement" === nodeType ||
    "ParenthesizedExpression" === nodeType ||
    "TypeCastExpression" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isFor(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "For" ||
    "ForInStatement" === nodeType ||
    "ForStatement" === nodeType ||
    "ForOfStatement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isForXStatement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "ForXStatement" ||
    "ForInStatement" === nodeType ||
    "ForOfStatement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isFunction(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Function" ||
    "FunctionDeclaration" === nodeType ||
    "FunctionExpression" === nodeType ||
    "ObjectMethod" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ClassMethod" === nodeType ||
    "ClassPrivateMethod" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isFunctionParent(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "FunctionParent" ||
    "FunctionDeclaration" === nodeType ||
    "FunctionExpression" === nodeType ||
    "ObjectMethod" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ClassMethod" === nodeType ||
    "ClassPrivateMethod" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isPureish(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Pureish" ||
    "FunctionDeclaration" === nodeType ||
    "FunctionExpression" === nodeType ||
    "StringLiteral" === nodeType ||
    "NumericLiteral" === nodeType ||
    "NullLiteral" === nodeType ||
    "BooleanLiteral" === nodeType ||
    "RegExpLiteral" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "BigIntLiteral" === nodeType ||
    "DecimalLiteral" === nodeType ||
    (nodeType === "Placeholder" && "StringLiteral" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isDeclaration(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Declaration" ||
    "FunctionDeclaration" === nodeType ||
    "VariableDeclaration" === nodeType ||
    "ClassDeclaration" === nodeType ||
    "ExportAllDeclaration" === nodeType ||
    "ExportDefaultDeclaration" === nodeType ||
    "ExportNamedDeclaration" === nodeType ||
    "ImportDeclaration" === nodeType ||
    "DeclareClass" === nodeType ||
    "DeclareFunction" === nodeType ||
    "DeclareInterface" === nodeType ||
    "DeclareModule" === nodeType ||
    "DeclareModuleExports" === nodeType ||
    "DeclareTypeAlias" === nodeType ||
    "DeclareOpaqueType" === nodeType ||
    "DeclareVariable" === nodeType ||
    "DeclareExportDeclaration" === nodeType ||
    "DeclareExportAllDeclaration" === nodeType ||
    "InterfaceDeclaration" === nodeType ||
    "OpaqueType" === nodeType ||
    "TypeAlias" === nodeType ||
    "EnumDeclaration" === nodeType ||
    "TSDeclareFunction" === nodeType ||
    "TSInterfaceDeclaration" === nodeType ||
    "TSTypeAliasDeclaration" === nodeType ||
    "TSEnumDeclaration" === nodeType ||
    "TSModuleDeclaration" === nodeType ||
    (nodeType === "Placeholder" && "Declaration" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isPatternLike(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "PatternLike" ||
    "Identifier" === nodeType ||
    "RestElement" === nodeType ||
    "AssignmentPattern" === nodeType ||
    "ArrayPattern" === nodeType ||
    "ObjectPattern" === nodeType ||
    (nodeType === "Placeholder" &&
      ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode))
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isLVal(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "LVal" ||
    "Identifier" === nodeType ||
    "MemberExpression" === nodeType ||
    "RestElement" === nodeType ||
    "AssignmentPattern" === nodeType ||
    "ArrayPattern" === nodeType ||
    "ObjectPattern" === nodeType ||
    "TSParameterProperty" === nodeType ||
    (nodeType === "Placeholder" &&
      ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode))
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSEntityName(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "TSEntityName" ||
    "Identifier" === nodeType ||
    "TSQualifiedName" === nodeType ||
    (nodeType === "Placeholder" && "Identifier" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isLiteral(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Literal" ||
    "StringLiteral" === nodeType ||
    "NumericLiteral" === nodeType ||
    "NullLiteral" === nodeType ||
    "BooleanLiteral" === nodeType ||
    "RegExpLiteral" === nodeType ||
    "TemplateLiteral" === nodeType ||
    "BigIntLiteral" === nodeType ||
    "DecimalLiteral" === nodeType ||
    (nodeType === "Placeholder" && "StringLiteral" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isImmutable(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Immutable" ||
    "StringLiteral" === nodeType ||
    "NumericLiteral" === nodeType ||
    "NullLiteral" === nodeType ||
    "BooleanLiteral" === nodeType ||
    "BigIntLiteral" === nodeType ||
    "JSXAttribute" === nodeType ||
    "JSXClosingElement" === nodeType ||
    "JSXElement" === nodeType ||
    "JSXExpressionContainer" === nodeType ||
    "JSXSpreadChild" === nodeType ||
    "JSXOpeningElement" === nodeType ||
    "JSXText" === nodeType ||
    "JSXFragment" === nodeType ||
    "JSXOpeningFragment" === nodeType ||
    "JSXClosingFragment" === nodeType ||
    "DecimalLiteral" === nodeType ||
    (nodeType === "Placeholder" && "StringLiteral" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isUserWhitespacable(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "UserWhitespacable" ||
    "ObjectMethod" === nodeType ||
    "ObjectProperty" === nodeType ||
    "ObjectTypeInternalSlot" === nodeType ||
    "ObjectTypeCallProperty" === nodeType ||
    "ObjectTypeIndexer" === nodeType ||
    "ObjectTypeProperty" === nodeType ||
    "ObjectTypeSpreadProperty" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isMethod(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Method" ||
    "ObjectMethod" === nodeType ||
    "ClassMethod" === nodeType ||
    "ClassPrivateMethod" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isObjectMember(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "ObjectMember" ||
    "ObjectMethod" === nodeType ||
    "ObjectProperty" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isProperty(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Property" ||
    "ObjectProperty" === nodeType ||
    "ClassProperty" === nodeType ||
    "ClassPrivateProperty" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isUnaryLike(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "UnaryLike" ||
    "UnaryExpression" === nodeType ||
    "SpreadElement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isPattern(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Pattern" ||
    "AssignmentPattern" === nodeType ||
    "ArrayPattern" === nodeType ||
    "ObjectPattern" === nodeType ||
    (nodeType === "Placeholder" && "Pattern" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isClass(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Class" ||
    "ClassExpression" === nodeType ||
    "ClassDeclaration" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isModuleDeclaration(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "ModuleDeclaration" ||
    "ExportAllDeclaration" === nodeType ||
    "ExportDefaultDeclaration" === nodeType ||
    "ExportNamedDeclaration" === nodeType ||
    "ImportDeclaration" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isExportDeclaration(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "ExportDeclaration" ||
    "ExportAllDeclaration" === nodeType ||
    "ExportDefaultDeclaration" === nodeType ||
    "ExportNamedDeclaration" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isModuleSpecifier(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "ModuleSpecifier" ||
    "ExportSpecifier" === nodeType ||
    "ImportDefaultSpecifier" === nodeType ||
    "ImportNamespaceSpecifier" === nodeType ||
    "ImportSpecifier" === nodeType ||
    "ExportNamespaceSpecifier" === nodeType ||
    "ExportDefaultSpecifier" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isFlow(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Flow" ||
    "AnyTypeAnnotation" === nodeType ||
    "ArrayTypeAnnotation" === nodeType ||
    "BooleanTypeAnnotation" === nodeType ||
    "BooleanLiteralTypeAnnotation" === nodeType ||
    "NullLiteralTypeAnnotation" === nodeType ||
    "ClassImplements" === nodeType ||
    "DeclareClass" === nodeType ||
    "DeclareFunction" === nodeType ||
    "DeclareInterface" === nodeType ||
    "DeclareModule" === nodeType ||
    "DeclareModuleExports" === nodeType ||
    "DeclareTypeAlias" === nodeType ||
    "DeclareOpaqueType" === nodeType ||
    "DeclareVariable" === nodeType ||
    "DeclareExportDeclaration" === nodeType ||
    "DeclareExportAllDeclaration" === nodeType ||
    "DeclaredPredicate" === nodeType ||
    "ExistsTypeAnnotation" === nodeType ||
    "FunctionTypeAnnotation" === nodeType ||
    "FunctionTypeParam" === nodeType ||
    "GenericTypeAnnotation" === nodeType ||
    "InferredPredicate" === nodeType ||
    "InterfaceExtends" === nodeType ||
    "InterfaceDeclaration" === nodeType ||
    "InterfaceTypeAnnotation" === nodeType ||
    "IntersectionTypeAnnotation" === nodeType ||
    "MixedTypeAnnotation" === nodeType ||
    "EmptyTypeAnnotation" === nodeType ||
    "NullableTypeAnnotation" === nodeType ||
    "NumberLiteralTypeAnnotation" === nodeType ||
    "NumberTypeAnnotation" === nodeType ||
    "ObjectTypeAnnotation" === nodeType ||
    "ObjectTypeInternalSlot" === nodeType ||
    "ObjectTypeCallProperty" === nodeType ||
    "ObjectTypeIndexer" === nodeType ||
    "ObjectTypeProperty" === nodeType ||
    "ObjectTypeSpreadProperty" === nodeType ||
    "OpaqueType" === nodeType ||
    "QualifiedTypeIdentifier" === nodeType ||
    "StringLiteralTypeAnnotation" === nodeType ||
    "StringTypeAnnotation" === nodeType ||
    "SymbolTypeAnnotation" === nodeType ||
    "ThisTypeAnnotation" === nodeType ||
    "TupleTypeAnnotation" === nodeType ||
    "TypeofTypeAnnotation" === nodeType ||
    "TypeAlias" === nodeType ||
    "TypeAnnotation" === nodeType ||
    "TypeCastExpression" === nodeType ||
    "TypeParameter" === nodeType ||
    "TypeParameterDeclaration" === nodeType ||
    "TypeParameterInstantiation" === nodeType ||
    "UnionTypeAnnotation" === nodeType ||
    "Variance" === nodeType ||
    "VoidTypeAnnotation" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isFlowType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "FlowType" ||
    "AnyTypeAnnotation" === nodeType ||
    "ArrayTypeAnnotation" === nodeType ||
    "BooleanTypeAnnotation" === nodeType ||
    "BooleanLiteralTypeAnnotation" === nodeType ||
    "NullLiteralTypeAnnotation" === nodeType ||
    "ExistsTypeAnnotation" === nodeType ||
    "FunctionTypeAnnotation" === nodeType ||
    "GenericTypeAnnotation" === nodeType ||
    "InterfaceTypeAnnotation" === nodeType ||
    "IntersectionTypeAnnotation" === nodeType ||
    "MixedTypeAnnotation" === nodeType ||
    "EmptyTypeAnnotation" === nodeType ||
    "NullableTypeAnnotation" === nodeType ||
    "NumberLiteralTypeAnnotation" === nodeType ||
    "NumberTypeAnnotation" === nodeType ||
    "ObjectTypeAnnotation" === nodeType ||
    "StringLiteralTypeAnnotation" === nodeType ||
    "StringTypeAnnotation" === nodeType ||
    "SymbolTypeAnnotation" === nodeType ||
    "ThisTypeAnnotation" === nodeType ||
    "TupleTypeAnnotation" === nodeType ||
    "TypeofTypeAnnotation" === nodeType ||
    "UnionTypeAnnotation" === nodeType ||
    "VoidTypeAnnotation" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isFlowBaseAnnotation(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "FlowBaseAnnotation" ||
    "AnyTypeAnnotation" === nodeType ||
    "BooleanTypeAnnotation" === nodeType ||
    "NullLiteralTypeAnnotation" === nodeType ||
    "MixedTypeAnnotation" === nodeType ||
    "EmptyTypeAnnotation" === nodeType ||
    "NumberTypeAnnotation" === nodeType ||
    "StringTypeAnnotation" === nodeType ||
    "SymbolTypeAnnotation" === nodeType ||
    "ThisTypeAnnotation" === nodeType ||
    "VoidTypeAnnotation" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isFlowDeclaration(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "FlowDeclaration" ||
    "DeclareClass" === nodeType ||
    "DeclareFunction" === nodeType ||
    "DeclareInterface" === nodeType ||
    "DeclareModule" === nodeType ||
    "DeclareModuleExports" === nodeType ||
    "DeclareTypeAlias" === nodeType ||
    "DeclareOpaqueType" === nodeType ||
    "DeclareVariable" === nodeType ||
    "DeclareExportDeclaration" === nodeType ||
    "DeclareExportAllDeclaration" === nodeType ||
    "InterfaceDeclaration" === nodeType ||
    "OpaqueType" === nodeType ||
    "TypeAlias" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isFlowPredicate(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "FlowPredicate" ||
    "DeclaredPredicate" === nodeType ||
    "InferredPredicate" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isEnumBody(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "EnumBody" ||
    "EnumBooleanBody" === nodeType ||
    "EnumNumberBody" === nodeType ||
    "EnumStringBody" === nodeType ||
    "EnumSymbolBody" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isEnumMember(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "EnumMember" ||
    "EnumBooleanMember" === nodeType ||
    "EnumNumberMember" === nodeType ||
    "EnumStringMember" === nodeType ||
    "EnumDefaultedMember" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isJSX(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "JSX" ||
    "JSXAttribute" === nodeType ||
    "JSXClosingElement" === nodeType ||
    "JSXElement" === nodeType ||
    "JSXEmptyExpression" === nodeType ||
    "JSXExpressionContainer" === nodeType ||
    "JSXSpreadChild" === nodeType ||
    "JSXIdentifier" === nodeType ||
    "JSXMemberExpression" === nodeType ||
    "JSXNamespacedName" === nodeType ||
    "JSXOpeningElement" === nodeType ||
    "JSXSpreadAttribute" === nodeType ||
    "JSXText" === nodeType ||
    "JSXFragment" === nodeType ||
    "JSXOpeningFragment" === nodeType ||
    "JSXClosingFragment" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isPrivate(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "Private" ||
    "ClassPrivateProperty" === nodeType ||
    "ClassPrivateMethod" === nodeType ||
    "PrivateName" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSTypeElement(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "TSTypeElement" ||
    "TSCallSignatureDeclaration" === nodeType ||
    "TSConstructSignatureDeclaration" === nodeType ||
    "TSPropertySignature" === nodeType ||
    "TSMethodSignature" === nodeType ||
    "TSIndexSignature" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "TSType" ||
    "TSAnyKeyword" === nodeType ||
    "TSBooleanKeyword" === nodeType ||
    "TSBigIntKeyword" === nodeType ||
    "TSIntrinsicKeyword" === nodeType ||
    "TSNeverKeyword" === nodeType ||
    "TSNullKeyword" === nodeType ||
    "TSNumberKeyword" === nodeType ||
    "TSObjectKeyword" === nodeType ||
    "TSStringKeyword" === nodeType ||
    "TSSymbolKeyword" === nodeType ||
    "TSUndefinedKeyword" === nodeType ||
    "TSUnknownKeyword" === nodeType ||
    "TSVoidKeyword" === nodeType ||
    "TSThisType" === nodeType ||
    "TSFunctionType" === nodeType ||
    "TSConstructorType" === nodeType ||
    "TSTypeReference" === nodeType ||
    "TSTypePredicate" === nodeType ||
    "TSTypeQuery" === nodeType ||
    "TSTypeLiteral" === nodeType ||
    "TSArrayType" === nodeType ||
    "TSTupleType" === nodeType ||
    "TSOptionalType" === nodeType ||
    "TSRestType" === nodeType ||
    "TSUnionType" === nodeType ||
    "TSIntersectionType" === nodeType ||
    "TSConditionalType" === nodeType ||
    "TSInferType" === nodeType ||
    "TSParenthesizedType" === nodeType ||
    "TSTypeOperator" === nodeType ||
    "TSIndexedAccessType" === nodeType ||
    "TSMappedType" === nodeType ||
    "TSLiteralType" === nodeType ||
    "TSExpressionWithTypeArguments" === nodeType ||
    "TSImportType" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isTSBaseType(node?: any | null, opts?: any): boolean {
  if (!node) return false;

  const nodeType = node.type;
  if (
    nodeType === "TSBaseType" ||
    "TSAnyKeyword" === nodeType ||
    "TSBooleanKeyword" === nodeType ||
    "TSBigIntKeyword" === nodeType ||
    "TSIntrinsicKeyword" === nodeType ||
    "TSNeverKeyword" === nodeType ||
    "TSNullKeyword" === nodeType ||
    "TSNumberKeyword" === nodeType ||
    "TSObjectKeyword" === nodeType ||
    "TSStringKeyword" === nodeType ||
    "TSSymbolKeyword" === nodeType ||
    "TSUndefinedKeyword" === nodeType ||
    "TSUnknownKeyword" === nodeType ||
    "TSVoidKeyword" === nodeType ||
    "TSThisType" === nodeType ||
    "TSLiteralType" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isNumberLiteral(node?: any | null, opts?: any): boolean {
  console.trace(
    "The node type NumberLiteral has been renamed to NumericLiteral",
  );
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "NumberLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isRegexLiteral(node?: any | null, opts?: any): boolean {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "RegexLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isRestProperty(node?: any | null, opts?: any): boolean {
  console.trace("The node type RestProperty has been renamed to RestElement");
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "RestProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
export function isSpreadProperty(node?: any | null, opts?: any): boolean {
  console.trace(
    "The node type SpreadProperty has been renamed to SpreadElement",
  );
  if (!node) return false;

  const nodeType = node.type;
  if (nodeType === "SpreadProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  return false;
}
